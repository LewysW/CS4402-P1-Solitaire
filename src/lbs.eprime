language ESSENCE' 1.0

given cards : matrix indexed by [ int(1..n) ] of int(0..51) where alldifferent(cards)

letting ROWS = int(1..n)
letting COLUMNS = int(1..n)
letting MOVES = n
letting SUIT = 13

find piles : matrix indexed by [ROWS, COLUMNS] of int(-1..51)

such that

$Cards in first pile must be unique cards from cards list
forAll card : int(1..n) .
  piles[1, card] = cards[card],


$Number of empty piles must increase as moves are made
forAll pile : int(2..n) .
  forAll card : int((n - pile + 2)..n) .
    piles[pile, card] = -1,

$For all piles
forAll pile : int(1..n-1) .
$There exists a source card which is not the first card
 exists src : int(2..(n - pile + 1)) .
 $And there exists a destination card which is one or three spaces left of the source
  exists dest : int(src - 3,src - 1) .
    $Where the destination card in the new pile, equals the source card of the old pile
    ((piles[pile + 1, dest] = piles[pile, src])
      $And the destination card of the old pile must either have the same suit or rank as the source card
      /\
      ((piles[pile, dest] % SUIT = piles[pile, src] % SUIT)
      \/
      (piles[pile, dest] / SUIT = piles[pile, src] / SUIT)))
      /\
      $And all for all other cards
      (forAll card : int(1..(n - pile + 1)) .
      $If the card's position is greater than the source card then its position changes by -1
        (card != dest /\ (src < card) -> (piles[pile + 1, card - 1] = piles[pile, card]))
        /\
        $And if the card's position is less than the source card then its position is unchanged
        (card != dest /\ (src > card) -> (piles[pile + 1, card] = piles[pile, card])))





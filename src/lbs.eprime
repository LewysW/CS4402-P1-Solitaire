language ESSENCE' 1.0

given cards : matrix indexed by [ int(1..n) ] of int(0..51) where alldifferent(cards)

letting ROWS = int(1..n)
letting COLUMNS = int(1..n)
letting MOVES = n
letting SUIT = 13

find piles : matrix indexed by [ROWS, COLUMNS] of int(-1..51)

such that

$Cards in first pile must be unique cards from cards list
forAll card : int(1..n) .
  piles[1, card] = cards[card],


$Number of empty piles must increase as moves are made
forAll pile : int(2..n) .
  forAll card : int((n - pile + 2)..n) .
    piles[pile, card] = -1,

$Ensures that all cards in piles must be present in the deck of cards
forAll pile : int(1..n) .
  forAll card : int(1..(n - pile + 1)) .
    piles[pile, card] in toSet(cards),

$Ensures no card is repeat at each stage (except for empty piles)
forAll pile : int(1..n) .
    alldifferent_except(piles[pile,..], -1),

$Card cannot make a reappearance after being replaced
forAll pile : int(1..n-1) .
  forAll card : int(1..(n - pile + 1)) .
    $If there is a card in the first pile but not the second
    (piles[pile, card] = ((sum(piles[pile,..])) - (sum(piles[pile + 1,..])) - 1)) ->
      $Card will not reappear in subsequent rows
      forAll p : int(pile + 1..n) .
        forAll c : int(1..(n - p + 1)) .
          piles[pile, card] != piles[p, c],


$Card is replaced by either adjacent card or card three spaces away
forAll pile : int(1..n-1) .
  forAll card : int(1..(n - pile + 1)) .
    $If there is a card in the first pile but not the second
    (piles[pile, card] = ((sum(piles[pile,..])) - (sum(piles[pile + 1,..])) - 1)) ->
      $Card must have been replaced by a card from index i + 1 or i + 3
      piles[pile + 1, card] = piles[pile, card + 1]
      \/
      piles[pile + 1, card] = piles[pile, card + 3],

$If card was replaced by adjacent card then old value must have been same suit or rank as new value
forAll pile : int(2..n) .
  forAll card : int(1..(n - pile + 1)) .
    (piles[pile, card] = piles[pile - 1, card + 1]) ->
      (piles[pile - 1, card] % SUIT) = (piles[pile - 1, card + 1] % SUIT)
      \/ (piles[pile - 1, card] / SUIT) = (piles[pile - 1, card + 1] / SUIT),

$If card was replaced by card three spaces away then old value must have had same suit or rank as new value
forAll pile : int(2..n) .
  forAll card : int(1..(n - pile + 1)) .
    (piles[pile, card] = piles[pile - 1, card + 3]) ->
      (piles[pile - 1, card] % SUIT) = (piles[pile - 1, card + 3] % SUIT)
      \/ (piles[pile - 1, card] / SUIT) = (piles[pile - 1, card + 3] / SUIT),

$Card being replaced must have same rank or suit value as either adjacent card
$or card 3 spaces away
forAll pile : int(1..n-1) .
  forAll card : int(1..(n - pile + 1)) .
    $If there is a card in the first pile but not the second
    (piles[pile, card] = ((sum(piles[pile,..])) - (sum(piles[pile + 1,..])) - 1)) ->
      $Card at i + 1 or i + 3 must have same suit or rank
      ((piles[pile, card] % SUIT) = (piles[pile, card + 1] % SUIT))
      \/
      ((piles[pile, card] / SUIT) = (piles[pile, card + 1] / SUIT))
      \/
      ((piles[pile, card] % SUIT) = (piles[pile, card + 3] % SUIT))
      \/
      ((piles[pile, card] / SUIT) = (piles[pile, card + 3] / SUIT))
